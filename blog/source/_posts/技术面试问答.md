---
title: 技术面试问答
date: 2019-07-26 22:00:00
tags:
- 面试
categories:
- 技术
---
# 技术面试问答

部分参考：https://snailclimb.top/JavaGuide

## Spring 
### 说一说 IOC和 AOP
- IOC

**控制反转**：基于**依赖倒置原则**的一种解耦的设计思想，可通过第三方容器Spring IOC容器实现，最常见的方式叫做**依赖注入**（依赖注入就是将实例变量传入到一个对象中去）。

- AOP

**面向切面编程**：AOP思想的实现一般都是基于 **代理模式**，在JAVA中一般采用JDK动态代理模式，Spring AOP 同时支持 CGLIB、ASPECTJ、JDK动态代理。




### SpringMVC工作流程
通过前端控制器DispatcherServlet接收客户端请求
1.找到处理器映射 HandlerMapping (返回一个执行链)解析请求对应的 Handler；
2.通过HandlerAdapter执行Handler，调用真正的Handler处理器（controller）处理请求，返回ModelAndView；
3.通过视图解析器进行解析，返回视图对象；
4.视图渲染，将模型数据填充到request域中


### Spring AOP和JDK动态代理（代理模式）

#### JDK动态代理

参考[JDK动态代理实现原理](https://www.cnblogs.com/zuidongfeng/p/8735241.html)InvocationHandler 

**流程**

1、为接口创建代理类的字节码文件(代理类com.sun.proxy$Proxy0.class)；

2、使用ClassLoader将字节码文件加载到JVM；

3、创建代理类实例对象，执行对象的目标方法。

**实现原理**

1、生成的代理类继承了Proxy类并且实现了要代理的接口，**由于java不支持多继承，所以JDK动态代理不能代理类；**

2、重写了equals、hashCode、toString；

3、通过invoke执行代理类中的目标方法doSomething；

4、有一个静态代码块，通过反射获得代理类的所有方法（用于2、3）。

### CGLIB

CGLIB底层使用了ASM（一个短小精悍的字节码操作框架）来操作字节码生成新的类（Groovy也是如此）

**ASM**：ASM 从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够直接产生二进制 class 文件。

区别：

- Java动态代理只能够对接口进行代理，CGLIB能够代理接口、普通类；

- Java动态代理通过反射实现，生成类更高效，CGLIB使用ASM框架直接对字节码进行操作，执行类时比较高效。

#### Spring AOP 

会这样子来进行切换，因为Spring AOP 同时支持 CGLIB、ASPECTJ、JDK动态代理

- 如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；
- 如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类（代理对象的子类）——不过这个选择过程对开发者完全透明、开发者也无需关心。

### Spring循环依赖

[参考文章](<https://blog.csdn.net/u010853261/article/details/77940767>)，目前Spring中存在两种循环依赖

1、构造器的循环依赖 （没法解决，构造器必须是在获取引用之前）

2、field属性或setter的循环依赖（对象的field属性或setter是可以延后设置的）

循环依赖的检测：Bean在创建的时候会打上标签，在递归调用的时候发现依赖的对象正在创建中则说明循环依赖。

**解决方法**

**Spring单例Bean初始化三步**

1. createBeanInstance实例化（此时只是调用了构造方法）；
2. populateBean属性填充(populate)；
3. initializeBean初始化（init方法|AfterPropertiesSet方法）

**三级缓存**

Spring在Bean创建的过程，会尝试从缓存中获取，按顺序singletonObjects（一级） 、earlySingletonObjects（二级） 、singletonFactories （三级）。

**简单过程**

当A类B类存在field属性依赖时

1. A类在完成初始化第一步时，将自己放入到第三级缓存中；
2. 初始化第二步，检测到依赖B，则尝试加载，此时B不存在需要创建；
3. B类相同，但是在查找A的时候从第三级缓存中发现，则完成B的后续初始化放入一级缓存；
4. 当B类完成之后，回到A类继续完成后续流程。




## 设计模式
### 单例模式

```java
/**
* 双重检查加锁
*/
public class Singleton{
    private volatile static Singleton instance = null;
    private Singleton(){}
    public Singleton getInstance(){
        if(singleton == null){
            synchronized(Singleton.class){
                if(singleton == null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}

/**
*静态内置类方式实现
*/
public class Singleton{
    private static class SingletonHolder{
        private static final Singleton INSTANCE = new Singleton();
    }
    private Singleton(){}
    public Singleton getInstance(){
        return SingletonHolder.INSTANCE;
    }
}

/**
*枚举方式(序列化中的readObject方法，不管是显式的还是默认的，它都会返回一个新建的实例)
*可避免反射攻击，以及避免序列化问题
*/
 

```





## Redis
### 缓存相关问题
- **缓存穿透**：查询一个数据库一定不存在的数据。
  **解决方案**
  1.如果从数据库中查询不到则短期缓存空值
  2.采用布隆过滤器，可能存在的数据哈希到一个足够大的bitMap中，拦截识别。
> 布隆过滤器：真实的数据通过多个hash函数，映射到大的bit数组中标记为1(默认全为0)，请求的数据通过那些hash函数计算映射的bit位置是否为1来判断。但是由于bit数组较小（远小于需要缓存的数据个数），所以位置覆盖和误差的问题。通过调节hash函数及bit数组大小来空值误判率。

3. 个人理解：key的生成采用类似银行卡号的方式，最后一位为校验位，可通过前面的值计算出，这个就可以在网关计算拦截。

- **缓存雪崩**
在某一个时间段，缓存集中过期失效（对于数据库而言，就会产生周期性的压力波峰）；或者redis出现宕机。
**解决方案**
1、分类设置不同的缓存周期，同类加上一个随机因子；
2、增加互斥锁（通过setnx的方式 ，后续请求不走数据库），控制数据库请求，重建缓存；
3、提高缓存的HA，如：redis集群。
对于服务可以
（1）熔断模式，对于后续请求，直接返回，快速释放资源（采用hystrix）。
（2）隔离模式，服务独立拆分，或者可以对不同类型的请求使用线程池来资源隔离（线程池隔离模式、信号量隔离模式）
（3）限流模式，提前对各个类型的请求设置最高的QPS阈值，若高于设置的阈值则对该请求直接返回，不再调用后续资源。

- **缓存击穿**
一个热点key失效的瞬间，持续的大并发就穿破缓存
**解决方案**
1.设置永不过期
2.使用互斥锁（mutex key），redis中setnx，不存在则设置成功返回1，否则返回失败0.

### Redis持久化方式
RDB： 快照形式  （定期将当前时刻的数据保存磁盘中）会产生一个dump.rdb文
AOF：append only file  (所有对redis的操作命令记录在aof文件中)，恢复数据，重新执行一遍即可。

#### Redis集群方式
1.主从复制：分为Master和Slave两个节点，主机会自动将数据同步到从机。
复制原理：从机（通信通过发送psync）连接到主机后，将主机发过来的快照（bgsave方式生成的rdb）载入（丢弃旧数据）--**全量复制** ，接着接收并执行来自主机的写命令（非阻塞的方式）--**异步复制**。如果全量复制过程中主从中断，再次连接时会触发**增量复制**，master从backlog中获取丢失的数据发送给slave，其中backlog的数据下标就是是slave返回的psync中的offset.

2.哨兵模式：类似于主从，只是主机出现故障时可自动将从机转换为主机等。
哨兵原理：每个Sentinel（哨兵）进程以每秒一次的频率向集群的主机、从机及其他哨兵进程发送ping命令，如果主机超过回复时间，则标记**主观下线**。此时所有哨兵以每秒的频率确认此台主机主观下线，当足够的哨兵确认后，则标记此主机**客观下线**。之后向对应的从机发送info命令的频率改为一秒（之前是10秒），从机改为主机。（之前若是少数通过或者主机应答，则清除对应的标记状态）

3.Redis-Cluster集群：
之前的模式都是存相同的数据，这种集群方式类似于分片，每台主节点上都存储不同的内容。所有的redis节点彼此互联(PING-PONG机制)，内部使用二进制协议优化传输速度和带宽。
每个节点包含：slot槽（0-16383）和cluster，前者用于决定当前节点包含的取值范围，后者用于管理集群。每个节点包含不同的哈希槽，通过算法计算数据存放位置。理论上只需要链接一个节点即可查询所以数据。
另外集群引入主从模式，保证高可用。
前公司采用三主三从的方式搭建的redis集群。

## zookeeper
### zk选举机制

### zk分布式锁

Zookeeper分布式锁，持久和临时节点（客户端与zk服务断开则删除）及各自的顺序节点。

**原理**：基于临时顺序节点

1、客户端c1想获取锁的时候，会在ParentLock下面创建一个临时节点Lock1，c1查找ParentLock下面的所有节点并排序，并判断Lock1是否为第一节点，是则获取 锁；

2、c2想获取锁的时候相同，此时临时节点Lock2不是第一节点，则Lock2监听自己前一节点Lock1（通过注册Watcher），进入等待状态。

zookeeper第三方库[Curator](https://curator.apache.org/)客户端，InterProcessMutex中的acquire方法用于获取锁，release方法用于释放锁。

## Java进阶
### 类加载过程

JVM类加载过程

**1. 加载**：将类的class文件读入到内存，并为之创建一个java.lang.Class对象，由**类加载器**完成。

**2. 连接**：
-- **验证**：验证字节码是否符合规范，语法分析校验是否合法，符号引用验证等
-- **准备**：为类变量（static修饰，此处区分实例变量）分配内存并设置变量默认初始值，如int赋值0
-- **解析**：将常量池内符号引用替换为直接引用

**3. 初始化**：

执行类构造器<clinit>()方法的过程，给类变量static赋值。（与准备阶段不同，现在是真正的赋值）

此处如果静态字段被final修饰（相当于宏变量），则编译器优化已经放入常量池，不会触发初始化。

> 类变量：静态变量属于类，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。
> 实例变量：实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。

**加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。**

**类加载触发条件**：

- 调用静态成员时，会加载静态成员真正所在的类及其父类；
- 使用new实例的时候（第一次new此对象）；
- 加载子类时候，先加载父类；
- public  final static修饰的属性且在编译时就能确定值，相当于常量，则不会加载。

### 对象创建过程

在类加载之后，接着是Java对象的创建（堆内存）

**1. 类加载检查**

首先在常量池中检查这个类的符号引用是否能够定位到，以及类加载的三步是否完成，否则执行类加载过程。

**2. 分配内存**

为新生对象从堆区划分一块一定大小的内存（类加载完成之后便可决定），分配指针分为“指针碰撞”和“空闲列表”，追根溯源是由GC方式决定（堆是否规整），并发问题由TLAB+CAS保证。

**3. 初始化零值**

内存分配完毕之后，JVM为内存空间初始化零值（根据数据类型的不同而不同），保证java代码不赋初始值就可以使用。

**4. 设置对象头**

存放例如此对象是谁的类实例（**类元数据指针**），对象哈希码、GC分代年龄信息（**对象信息**）等。

**5. 执行init方法**

从JVM的角度来说基本完成，从程序的角度来说刚刚开始，进行init初始化。

**补充**

> 对象在**内存中的布局**可以分为 3 块区域：**对象头**、**实例数据**和**对齐填充**

> **对象访问** 分为两种（java栈的本地变量表中reference存放对应的地址）
> **句柄：**堆区划分内存作为句柄池，对象实例数据、类型数据的地址（方法区）
> **直接指针：**将对象实例数据与对象类型数据的地址绑定在一起，reference直接指向对象实例数据地址。

### JVM内存模型（JDK1.6）

JVM管理的内存分为**运行时数据区域** + **直接内存**（堆外内存）

**运行时数据区域**

- **线程共享**：
  - **堆**：用于存放对象实例、数组，是垃圾收集器管理的主要区域，俗称**GC堆**（可以分为新生代和老年代）。
  - **方法区**：是一种规范，用于储存被JVM加载的类信息、常量、静态变量、JIT 即时编译器编译后的代码。也称为永久代，HotSpot 虚拟机对虚拟机规范中**方法区的一种实现方式**（或说堆的一个逻辑部分）。包含运行时常量池。
  - **直接内存**（非运行时数据区域，但确实是共享）：
- **线程私有**：
  - **虚拟机栈**：一个个栈针组成，每个栈针包含局部变量表、操作数栈、动态链接、出口信息等，每次方法调用的数据都是通过栈传递的。（如果不能动态扩展，会受最大栈深影响）为java方法（字节码）服务。
  
> **局部变量表主要存放了编译器可知的各种数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。

  - **本地方法栈**：和虚拟机栈类似，主要为native方法服务。
  
  - **程序计数器**：当前线程所执行的字节码的行号指示器（字节码指令的地址），如果单线程操作按序执行就无需计数器，但是多线程切换的时候就需要计数器来记录线程的字节码执行位置来恢复流程。（**唯一一个不会出现 OOM 的内存区域**）

**直接内存**

直接内存由操作系统管理，可以减少GC，提高IO效率（堆内数据写入磁盘的时候，需要复制），java提供部分API操作。

> JDK1.7开始就陆续将方法区移除，改用**元空间**，使用直接内存。原因之一，方法区就可以不受JVM限制，只受系统内存的限制。
>
> **运行时常量池**是方法区的一部分，方法区在移除后运行时常量池就存放Java堆中。

### 常量池

以前放置于方法区，后来迁移到堆区

- 字符串常量池：用于存放字符串，StringTable的Hash表方式实现。

- class常量池：包含在class文件的类信息中，编译阶段，用于存放字面量 + 符号引用。（位于本地）

- 运行时常量池：class常量池被加载到内存之后的版本（也就是每个class都有一个运行时常量池），但是它的字面量可以动态的添加，符号引用可以被解析为直接引用。（而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中）

**字面量&符号引用**

- 字面量：1.文本字符串 2.八种基本类型的值 3.被声明为final的常量等;
- 符号引用：1.类和方法的全限定名 2.字段的名称和描述符 3.方法的名称和描述符。

### 垃圾回收

**1.分代回收算法**

目前主流的垃圾收集器都会采用分代回收算法，堆内存分为新生代和老年代。详细分为eden 区、s0("From") 区、s1("To") 区都属于新生代，tentired 区属于老年代。

- **新生代 GC（Minor GC）**:
- **老年代 GC（Major GC/Full GC）**:

**大对象直接进入老年代**

如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1.对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。

**2. 判断对象死亡**

- 引用计数法：对象中添加一个引用计数器，每当有一个地方引用它，计数器加 1；引用失效，计数器减 1。缺点：很难解决对象之间相互循环引用的问题。

- 可达性分析算法： **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。

引用分为强引用、软引用、弱引用、虚引用四种。

**强引用**：如果一个对象具有强引用，当内存空 间不足，垃圾回收器不会回收它。

**软引用**：如果内存空间足够，垃圾回收器就不会回收它；如果不足了，就会回收这些对象的内存。

**弱引用**：一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。

**虚引用**：如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。

**3. 垃圾收集算法**

-  **标记-清除算法**：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。内存分为可用内存、可回收内存、存活对象。

- **复制算法**：为了解决效率问题。将内存分为大小相同的两块，当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。

- **标记-整理算法**：与“标记-清除”算法类似，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存

- **分代收集算法**：只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。

  **新生代中，每次收集都会有大量对象死去，所以可以选择复制算法**。

  **老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。**

### JVM多线程

JVM的多线程是通过CPU时间片轮转（即线程轮流切换并分配处理器执行时间）算法来实现的



### String字符串

- String s1 = new String("abc"); 这种方式创建1-2对象，字符串常量池如果没有“abc”会创一个，new会在堆区创建一个，s1拿到的是堆区实例的应用。

- String str4 = str1 + str2; //会在堆上创建的新的对象，可查看class文件反编译的代码，内部做过优化。

  

### 数据可见性

> 当一个线程修改了线程共享变量的值，其它线程在使用前，能够得到最新的修改值。
> 弱一致：只保证用户见到的数据是一致的（中间修改过几次，只需保证最终有序）。
> 强一致：任意时刻，存储的数据都是一致的。



原因：同一个数据在不同的cpu核心的cache上可能不同。

CPU三级缓存L1 -> L2 -> L3

L1：包含分为独立的32K数据缓存+32K指令缓存（单核私有缓存）

L2：高效内存访问队列，连接L1、L3，L2缓存大小为256K(单核私有缓存）

L3：包括了在同一个槽上的所有L1和L2缓存中的数据（同插槽所有核心共享缓存）。



CPU先通过高速缓存再到主存存在**缓存一致性**问题，以及CPU指令重排问题（CPU会处理依赖，但是还是    会存在问题）。

方案：缓存到主存通过**缓存一致性协议(MESI)**解决。

```
CPU中每个缓存行（caceh line)使用4种状态进行标记（使用额外的两位(bit)表示):
M: 被修改（Modified)：该核独享，已被修改，待回写到主存中变为E
E: 独享的（Exclusive)：该核独享，与主存一致。写操作变为M，其他核读取变为S
S: 共享的（Shared)：该状态代表被多核缓存，与主存一致，当其中一核修改则其他核变为I
I: 无效的（Invalid）：该缓存无效（非M状态的缓存行随时作废，M必先写回主存）。
```

一个缓存除在`Invalid`状态外都可以满足cpu的读请求，一个`Invalid`的缓存行必须从主存中读取（变成`S`或者 `E`状态）来满足该`CPU`的读请求。

一个写请求只有在该缓存行是M或者E状态时才能被执行，如果缓存行处于`S`状态，必须先将其它缓存中该缓存行变成`Invalid`状态（写请求核缓存行变为M）。该操作经常作用广播的方式来完成。

**例子：**core1与core2使用共享变量x（此时状态为S），当core1修改时，core2缓存行会置位I，core1置为M，之后可能会变为E，广播发送时会锁住缓存间的总线。core2再使用时会重新获取。

### 重排序

> 编译器、底层硬件（CPU等）出于“优化”的目的，按照某种规则将指令重新排序（尽管有时候看起来像乱序）

操作系统和硬件层面则通过**内存屏障（内存栅栏）**解决：读屏障（Load Barrier）和写屏障（Store Barrier）。

```
1.阻止屏障两侧指令重排序
2.强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。
```



### 双亲委派



### Java锁机制

乐观锁、

悲观锁

自旋锁：线程一直在尝试获取锁。

非自旋锁：线程阻塞，待锁释放之后重新恢复获取。



### volatile & synschonized

**volatile**

1. 可见性，对于一个该变量的读，一定能看到读之前最后的写入。
2. 防止重排序。

**synchronized**

修饰同步语句块：通过添加monitorenter（开始位置）、monitorexit（结束位置），在java对象的对象头中获取锁信息，当锁计数器为0则成功获取并加1，执行到monitorexit后锁计数器归0，锁释放。

修饰方法：在flags标识中添加ACC_SYNCHRONIZED字段（其中还包public等方法权限），表明方法为同步方法

**区别**

- volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。
- volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性
- 

### ArrayList

基于Object[]数组实现，默认初始化为10。线程不安全

**扩容**：int newCapacity = oldCapacity + (oldCapacity >> 1)，相当于原来1.5倍。

**新增元素**：

1. 不指定位置，末尾追加

2. 指定位置， index+1复制

```
System.arraycopy(elementData, index, elementData, index + 1,size - index);
   
```
**删除元素**：同样采用System.arraycopy复制操作，指定值删除的时候循环匹配查找下标，再删除。 
**查询元素**：采用数组实现，天然支持下标快速访问。

### linkedlist 

基于双向链表实现，单元节点Node包含，数据、prev、next三个属性。线程不安全

**新增元素**：

1. 不指定位置，末尾追加

2. 指定位置，则先查找链表结点信息使用方法node(int index)，。时间复杂度O(n)。

**删除元素**：指定位置通过查询元素删除，指定值，则从头节点循环匹配，然后删除。节点删除unlink()方法

**查询元素**：使用node(int index)方法。基本思路如果index < (size >> 1)，也就是新增的位置在前半部分，从链表首部开始查找；否则从尾部

其中modCount参数，当链表被修改时会自增，可以防止迭代器创建之后，对表进行了修改。详情查看AbstractList中内部类ListItr的checkForComodification方法。

### HashMap&ConcurrentHashMap

HashMap基于数组+链表的方式储存（jdk1.8在链表过长的时候8，转换为红黑树，提高检索效率），如下图。
![img](https://upload-images.jianshu.io/upload_images/1017209-5f0382cbe72da521.png?imageMogr2/auto-orient/strip|imageView2/2/w/785/format/webp)


```java
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; //默认初始容量16
static final float DEFAULT_LOAD_FACTOR = 0.75f; //默认加载因子，对空间和时间效率的一个平衡选择
transient Node<K,V>[] table; //储存数据的节点数组，每个node节点包含hash,key,value,next属性
int threshold; //扩容阀值，所能容纳的最大数据量超过这个数目就重新resize(扩容)，threshold = capacity(容量) * loadFactor(加载因子)
transient int size; //总节点个数
```

**如何确定数据下标**

1. 计算key的hash值，(h = key.hashCode()) ^ (h >>> 16)，高低位异或运算，为了当容量较小的时候高位也能参与运算。
2. 根据hash值对容量取余，h & (length-1)，等于h % length，位运算效率更好。

*初始容量必须是 2 的幂次方，因为在平均分配的时候会取余操作，h & (length -1) == h % length，只有当length是 2 的幂次方时，length -1才能保证低位都为1，相当于取余操作。*

**扩容**：resize()，HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。最大容量1<<30超过就让其碰撞不再扩容。

**新增元素**：通过h & (length-1)获得数据节点，如果本节点为空直接新建节点；节点不为空（如果key相同直接覆盖）则循环链表直到链表尾部添加（如果是红黑树直接红黑树操作），如果key相同直接覆盖，当链表长度超过8则转换为红黑树结构（jdk1.8）。

**删除元素**：查询方法与查询元素类似，定位到数据节点后，如果是红黑树则采用红黑树删除的方法；否则将当前节点的前一节点的next节点指向当前节点的next节点。

**查找元素**：通过h & (length-1)查找数据节点，对比key，如果相同则直接返回；不同则循环遍历链表；如果是红黑树则采用红黑树的查询（hash对比，左右子节点递归调用，如果为当前节点对比key，ok则直接返回）。



### AtomicInteger & AtomicStampedReference

**AtomicInteger**：采用CAS（Compare And Swap），CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。

存在：ABA问题，即基于CAS方案时，可能存在其他线程从A -> B -> A改变，但是当前线程对比发现还是A，在部分情况下存在问题。

解决方案：各种乐观锁一般基于版本戳version解决

AtomicStampedReference：通过int整数stamp标记解决



### Java多线程

线程完整生命周期：新建状态（new）、就绪状态（start）、运行状态、阻塞状态、死亡状态。

![img](http://images.cnitblog.com/i/426802/201406/232002051747387.jpg)

**调用start方法方可启动线程并使线程进入就绪状态，而run方法只是thread的一个普通方法调用，还是在主线程里执行**

#### sleep()方法和wait()方法简单对比
1. sleep方法没有释放锁，而wait方法释放了锁。
2. wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。

#### 使用多线程常见的三种方式
继承Thread类、实现Runnable接口、使用ThreadPoolExecutor线程池创建（推荐）。

 newCachedThreadPool：可缓存的线程池，超长可回收空闲队列，无可回收则新建线程；

newFixedThreadPool：定长线程池，超出队列等待；

newScheduledThreadPool：定时定长线程池；

newSingleThreadExecutor：：单线程池，可定义规则FIFO、LIFO、优先级等。


### 继承

java类不允许多继承，但是接口可以；

python是运行多继承的，实现原理基于深度、广度优先搜索。



### 异常分类及事务异常捕获
Thorwable类是所有异常和错误的超类，有两个子类Error和Exception，分别表示错误和异常。
Error：一般是程序无法处理的错误，如：OutOfMemoryError，此时JVM一般会终止线程。
Exception：异常，一般分为运行时异常和非运行时异常
运行时异常（RuntimeException）称为不检查异常，编译时可以通过的，比如NPE
非运行时异常是除RuntimeException以外的异常称为检查异常，自己捕获或抛出。

### 过滤器&拦截器 

在java常说的过滤器Filter，是基于Servlet，生命周期交友Servlet管理。

而拦截器则通过动态代理的方式执行，独立存在，生命周期可交由IOC容器管理。



## 分布式架构&微服务
### 谈谈分布式架构&微服务
### 分布式一致性问题

### 分布式锁

参考https://blog.csdn.net/wuzhiwei549/article/details/80692278

1.基于数据库实现排他锁，新增数据及带状态更新（非重入可通过记录当前获取锁的机器信息及线程信息来恢复）；

2.基于redis的setnx方式（主机宕机且未及时同步从机则会出现问题）；

3.Zookeeper分布式锁。

总结：zk可靠性较好，redis性能较高。

### 脑裂（brain-split）

脑裂是指在主备切换时，由于切换不彻底或其他原因，导致客户端和Slave误以为出现两个active master，最终使得整个集群处于混乱状态。

1.添加冗余的heartbeat线，例如双线保证，减少故障；

2.fence设备

## dubbo
#### dubbo的工作原理

生产者、消费者、zk

1.生产者在服务启动的时候，向注册中心注册自己所提供的服务（ zk将服务信息写入到临时节点下面）；

2.消费者在服务启动的时候，向注册中心订阅自己所需服务 ;

3.注册中心返回服务提供者地址给消费者，如有数据变更，将通过长连接的方式推送给消费者；

4.消费者基于 软负载均衡算法，选取一台生产者调用，调用失败再选一台调用；

5.消费者生产者，在内存中累计调用次数&时间等，每分钟发送一次给监控中心。


## 算法
### 快排算法

https://polarisnosnow.github.io/2019/07/03/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/

### topK问题

从arr[1, n]这n个数中，找出最大的k个数，这就是经典的TopK问题，基于快排的思想，大致思路：

1. 随机取值（参考快排取值）作为中间数m，小于i则放入左边，大于放右边。
2. 左边个数多于K，说明第K位在右边，此时对右边做相同处理；如果少于，说明第K位在左边，做类似处理（如果左边刚好K位，则刚好）；m刚好是K位，则左边加m刚好。


## 数据库
### Mysql简介

MySQL 主要分为 **Server 层**和**引擎层**

- Server 层主要包括**连接器**、**查询缓存**(8.0 版本后移除)、**分析器**、**优化器**、**执行器**，同时还有一个日志模块（binlog-归档日志），这个日志模块所有执行引擎都可以共用。
- 引擎层是插件式的，主要负责数据的存储和读取，采用可以替换的插件式架构，目前主要包括，MyISAM，InnoDB，Memory 等。
> binlog：归档日志，将数据库的DDL和DML操作在二进制日志中。主要用于数据库的主从复制及增量复制。

执行流程：

- 查询语句的执行流程如下：权限校验（如果命中缓存）---》查询缓存---》分析器---》优化器---》权限校验---》执行器---》引擎
- 更新语句执行流程如下：分析器----》权限校验----》执行器---》引擎---redo log(prepare 状态---》binlog---》redo log(commit状态)

**异常处理**

如果在上述更新执行过程中，出现异常

- 判断redolog是否完整，完整则commit。
- 如果redolog只是prepare 状态，判断binlog是否完整，完整则commit，否则回滚事务。

**innoDB事务日志包括redo log和undo log**

redolog：重做日志，提供前滚操作。

undolog：回滚日志（逻辑），提供回滚和多个行版本控制(MVCC)。类似于将写命令逆操作化记录在日志中。

日志刷盘：https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html#auto_id_0

### 存储引擎

MyISAM：MySQL 5.5.5 以前默认存储引擎，非聚簇索引，表级锁

InnoDB：MySQL 5.5.5 版本开始作为默认存储引擎，聚簇索引，较好的支持事务，行级锁 



### Mysql索引

索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数，提升索引效率。

所以二叉树，红黑树都不行，深度太深。

**B树问题**
1.插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质。造成IO操作频繁。
2.区间查找可能需要返回上层节点重复遍历，IO操作繁琐。

同样Hash索引，只能用于精确查询，不支持排序等等问题。

**Mysql索引采用B+树存储**

Mysql在B+树的基础上做了修改，叶子节点之间添加了指针。

索引**是一个排序的列表**，在这个列表中存储着索引的值和包含这个值的数据所在行的物理地址，在数据十分庞大的时候，索引可以大大加快查询的速度，这是因为使用索引后可以不用扫描全表来定位某行的数据，而是先通过索引表找到该行数据对应的物理地址然后访问相应的数据。



### 聚簇索引&非聚簇索引

- 非聚集索引：一般的索引都为此种方式， 索引顺序与物理存储顺序不同；

- 聚集索引 ：数据库表行中数据的物理顺序与键值的逻辑（索引）顺序相同。

- **非聚簇索引**：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，是一种密集索引；

- **聚簇索引**：将数据存储与索引放到了一块（所以一张表只要一个），找到索引也就找到了数据，是一种稀疏索引

InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上。

MyISM使用的是非聚簇索引，主键索引B+树的节点存储了主键，叶子节点都使用一个地址指向真正的表数据。

> 聚簇索引适合用在排序的场合，范围查询，不适合频繁更新的列（需要移动叶子结点）及随机生成的列（UUID等，在新增的时候与前面有同样的问题）

InnoDB的辅助索引data域存储相应记录主键的值，然后再通过聚簇索引查询到所有的值；

MyISM的辅助索引与其本身的索引结构相同。

### 事务的ACID

原子性：指事物是最小的执行单位，不可分割。要么全部成功，要么全部失败。

一致性：执行事务前后，数据完整性保持一致。

隔离性：并发事务互不干扰，相互独立。

持久性：指事务成功结束后，对数据库的操作能永久保存下来，故障也能恢复。

### 数据库隔离机制

**三大并发问题**

- 脏读：A事务访问数据并修改，在提交之前，B事务也访问了此数据（读取还未提交的数据）。
- 不可重复读：A事务多次读取数据，读取中间，B事务修改该数据，导致A事务读取前后不一致。（修改）
- 幻读：与不可重复度读类似，A事务在读取多行数据的时候，B事务重新插入或删除了几行数据，导致A事务的“幻读“ 。（新增删除）
- 丢失修改：AB事务修改同一数据时候，导致某一修改丢失。

**四种隔离级别**

读取未提交（**READ-UNCOMMITTED**）：最低的隔离级别，可能会导致脏读、不可重复读、幻读。

读取已提交（**READ-COMMITTED**）：允许读取并发事务已经提交的数据，但会导致不可重复读，幻读。

可重复读（**REPEATABLE-READ**）：对于同一字段，在一个事务里读取结果是一致的。可以阻止脏读、不可重复读。

可串行化（**SERIALIZABLE**）：事务依次执行，完全符合ACID。

MySQL InnoDB存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重读）**，在 **分布式事务** 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别。

### InnoDB锁

MVVC：多版本并发控制。

InnoDB在RR的隔离级别下，采用Next-Key Lock 锁算法。

Next-Key Lock = Record lock（行锁） + Gap lock  （间隙锁）

Record Lock：单个行记录上的锁

Gap lock ：锁定一个范围，但不包括记录本身。

Next-Key Lock：1+2，锁定一个范围，并且锁定记录本身。主要解决幻读

### 锁的类型

**共享锁（S）**：又称读锁，所有事务只能读取，不能修改，其他事务可重复添加S锁。（多线程同时拥有）

**排他锁（X）**：又称写锁，加锁事务可读可写，其它事务不允许添加任何锁。（线程独占）

**意向共享（IS）**：InnoDB一个数据行加共享锁前必须先取得该表的IS锁

**意向排他（IX）**：类似同上

### 分表分库Sharding-JDBC





## 操作系统

### 内核态&用户态

把运行在操作系统上的进程称为用户进程，运行在**用户空间**；操作系统运行的空间称为**系统空间**。

对于普通的用户程序想要调动硬件，比如读写磁盘，需要用户进程通过系统空间，访问对应的外设。前面基本相当于用户态、内核态或是用户进程、系统进程。

### buffer缓冲区

缓冲区的作用就是存储读过的磁盘数据，下次有需求直接从缓冲区读取，缓冲区是内存区域，读取非常快速。

**用户缓冲区**：减少系统调用次数，降低内核态用户态切换耗时。

**内核缓冲区**：在OS级别，提高磁盘IO效率，优化磁盘写操作。

**硬件缓冲区**：硬件与OS之间的缓冲区域

数据交换流程：硬件缓冲区》》》内核缓冲区》》》用户缓冲区

> buffer和cache区别：前者相当于集中处理，堆积一定数量一次操作，减少操作次数；后者是提高数据访问效率，减少访问时间（不管是redis对于数据库，还是内存对于磁盘）。

## 网络

### BIO、NIO、AIO

同步：调用者等待被调用者返回结果，才能继续执行。

异步：被调用者接收到请求立即应答，但没有返回结果，而是通过状态、通知或回调机制主动通知调用者结果；

阻塞：blocking，调用方发起请求，在结果返回之前会一直将线程挂起；

非阻塞：non-blocking，IO操作被调用后理解返回用户一个状态值，无需等待IO操作彻底完成，调用者不会被挂起，可通过轮询等方式获取结果。

> 同步和异步：关注的是消息通信机制。
>
> 阻塞和非阻塞：关注调用者在等待结果返回之前所处的状态。

- **BIO（Blocking I/O）**：同步阻塞IO，数据的读取写入必须阻塞在一个线程内等待其完成，加上线程池生产的多线程可优化性能（活动连接数小于单机1000，性能不错）。缺点：线程创建、销毁、切换成本较高，消耗内存较多等等。

- **NIO（Non-blocking I/O）**：同步非阻塞的I/O模型，它支持面向缓冲的，基于通道的I/O操作方法。提供了 **Channel **, **Selector**，**Buffer**等抽象。**IO 面向流(Stream oriented)，而 NIO 面向缓冲区(Buffer oriented)。**
  - **Buffer**：Buffer是一个对象，它包含一些要写入或者要读出的数据。
  - **Channel** ：NIO 通过Channel（通道） 进行读写。通道是双向的，可读也可写，而流的读写是单向的。
  - **Selector**：多路复用器选择器，用于使用单个线程处理多个通道。多个Channel以事件的方式可以注册到同一个Selector，从而达到用一个线程处理多个请求成为可能。
- **AIO（Asynchronous I/O）**：也就是 NIO 2，异步非阻塞的IO模型，异步 IO 是基于事件和回调机制实现的。

BIO里用户最关心“我要读”，NIO里用户最关心"我可以读了"，在AIO模型里用户更需要关注的是“读完了”。

```
五种IO模型包括：阻塞IO、非阻塞IO、信号驱动IO、IO多路转接、异步IO。其中，前四个被称为同步IO。(参考：https://blog.csdn.net/ZWE7616175/article/details/80591587)
非阻塞IO：如果kernel数据没有准备还，就返回一个EWOULDBLOCK错误，通过轮询的方式实现。
信号驱动IO：应用进程告诉内核：当数据报准备好的时候，给我发送一个信号，对SIGIO信号进行捕捉，并且调用我的信号处理函数来获取数据报。
IO多路转接：IO多路转接是多了一个select函数，select函数有一个参数是文件描述符集合，对这些文件描述符进行循环监听，当某个文件描述符就绪时，就对这个文件描述符进行处理。
例子：一个人（线程）用鱼竿（方式）钓鱼。
```



### IO多路复用的机制
IO多路复用一次可以等多个**文件描述符（相当于文件的地址）**
select：select函数之后会一直监视这些文件描述符中有哪些可读，如果有可读的描述符那么我们的工作进程就去读取资源

poll：poll 在select （一个进程内1024个链接）基础上做了加强，可以维持任意数量的连接。

epoll：前面两种都基于轮询遍历，epoll是基于内核的反射机制，在有活跃的 socket 时，系统会调用我们提前设置的回调函数。